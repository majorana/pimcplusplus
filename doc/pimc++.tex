\documentclass{book}
%\usepackage{verbatim}
%\usepackage{moreverb}
%\usepackage{boxedminipage}
%\usepackage{shadow}
\usepackage{fancybox}
\usepackage{float}
\usepackage{amsmath}

\renewcommand{\shadowsize}{2pt}
\author{Kenneth P. Esler, Jr. and Bryan K. Clark}
\title{pimc++}
%\subtitle{Path Integral Monte Carlo Simulation Tool}

\begin{document}
\maketitle
\chapter{Introduction}
{\em pimc++} is a general, high-performance tool to perform
fully-correlated simulations of quantum systems at finite temperature.
In essense, it samples the many-body thermal density matrix to compute
thermal equilibrium averages of quantum observables.  Written in very
object-oriented C++, it is intended to be a nearly universal tool that
can be easily extended to perform novel simulations.  Its current
features include:
\begin{itemize}
  \item Arbitrary number of particles, species, and timeslices,
        limited only by memory requirements.
  \item Time-slices can be distributed across processors using MPI to
        communicate, making possible efficient simulations with
        thousands of time-slices.
  \item Multiple ``clones'' of the same simulation may be run with
        automatic generation of different random number seeds.  This
        can be used to improve statistics.
  \item Very high-accuracy pair-actions can be used.  These are
        generated with the coupled squarer++/fitter++ package.
  \item Bose, Fermi, and Boltzmann statistics are supported.
  \item Output is efficiently and accurately stored in HDF5 format.
  \item Extremely flexible input file format allows specification of
        the Monte Carlo algorithm in the input.
  \item Free and periodic boundary conditions are specified
        independently for each dimension allowing slab and column
        geometries. 
  \item Statistical analysis and HTML report generation with
        automatic creation of embedded plots.
  \item 3D OpenGL-based visualization tool can be used for debugging
        and pedagogy.  Supports exporting to the POVray ray-tracer for 
        photo-realistic rendering.  Also supports MPEG4 movie generation.
\end{itemize}

\chapter{Installing}
Suffice it to say that installing {\em pimc++} can be a quite a pain
in the caboose.

\chapter{Input Files}
\section{Introduction}
All of the file input and output in pimc++ is done through our 
C++ Input And Output ({\em CIAO}) library.  This library is designed
to provide a common programming interface to several hierachical data
formats.  In particular, we currently implement a custom ASCII format,
HDF5, and XML.  For input files, we use the ASCII format almost
exclusively.  For files which store heavy numeric data, such as the
pair action spline tables, we use HDF5.  XML is appealing for some
compatibility reasons, but we do not currently use it for anything.
The following sections will explain the use of our ASCII format.  

\section{Defining variables}
Upon looking at a sample input file, the reader will note a strong
resemblence to C++.  This was an intentional choice on the part of the
developers, since those who were familiar enough with C++ to extend
the code should feel quite at-home with this format.  There are very
few constructs to learn in the input files, yet we have found them to
be very versatile.  

Before diving into the details of the file format, let us begin with
an example.  In Figure~\ref{fig:InputEx}, we have a fictitious input
file in the {\em CIAO} ASCII format.
\begin{figure}
\shadowbox{\begin{minipage}{5in}
\begin{verbatim}
Section(System) {
  int NumParticles = 6;
  Array<double,1> Masses(6) = [ 0.5, 0.5, 0.5, 1.0, 1.0, 1.0 ];
}

Section(Potentials) {
  Section(Potential) {
    string Type = "Coulomb";
    double q1 = 1.0;
    double q2 = -1.0;
  }

  Section(Potential) {
    string Type = "Lennard-Jones";
    double sigma = 5.0;    // this is in units of bohr radii
    double epsilon = 3.2;  // and this is in Hartrees
  }
}
\end{verbatim}
\end{minipage}}
\caption{Example {\em CIAO} input file.}
\label{fig:InputEx}
\end{figure}

The most basic construct is a named variable to which a value is
assigned.  An example is \\
\rule{0.6cm}{0cm}\shadowbox{\parbox{4.4in}{\texttt{int NumParticles = 6;}}} \\
In this case, \texttt{NumParticles} is an {\em atomic} variable.
Currently, {\em CIAO} supports the atomic types {\texttt int, double,
  bool and string}.  It also supports array variables.  We have taken
the syntax for our array variables from the popular {\em blitz++}
template array package. \\
\rule{0.6cm}{0cm}\shadowbox{\parbox{4.4in}{\texttt{Array<double,1>
      Masses(6) = [0.5, 0.5, 0.5, 1.0, 1.0, 1.0]; }}} \\
Here, the \texttt{Array<double,1>} indicates a one-dimensional array
of doubles.  {\em CIAO} supports up to four-dimensional arrays.  The
\texttt{(6)} after the variable name, \texttt{Masses}, gives the size
of the array.  For a multidimensional array, the dimensions are
separated by commas, such as\\
\rule{0.6cm}{0cm}\shadowbox{\begin{minipage}{4.4in}
\begin{verbatim}
Array<double,2> Ident(3,3) = [ 1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0 ];
\end{verbatim}
\end{minipage}}\\
The blank lines are not required -- they are included only for
clarity.  

\section{Creating hierachy with sections}
Following the object-oriented paradigm, we find it to be extremely
useful to allow hierarchy in our input files.  We do this through the
use of {\em sections}.  A section is defined in the following way:\\
\rule{0.6cm}{0cm}\shadowbox{\begin{minipage}{4.4in}
\begin{verbatim}
  Section (Cattle) {
    Section (Cows) {
      Array<string,1> Names(2) = ["Bessie", "Bovina"];
      Array<int,1> NumSpots(2) = [1, 47];
    }
    Section (Bulls) {
      Array<string,1> Names(2) = ["Charger", "Red"];
      Array<int,1> NumSpots(2) = [13, 5];
    }
  }
\end{verbatim}
\end{minipage}}

\section{Format}
\section{Global parameters}
\section{The ``System'' section}
   The section descibes the system to be studied.  It specifies the
   size of the paths, the species and numbers of particles, the size
   of the box, etc.  Here, we will describe the required parameters
\begin{itemize}
   \item \texttt{NumTimeSlices}:  Integer variable giving the total
   number of time slices to use.  Thus
   $\texttt{tau}*\texttt{NumTimeSlices}$ gives the $\beta$ for the
   system.
   \item \texttt{Array<bool,1> IsPeriodic(NDIM)}:  This is an array of
   booleans of length 2 or 3, dependending on the dimensionality of
   the system, of whether the system is periodic in each of the
   cardinal directions, $\hat{x},\hat{y},\text{and } \hat{z}$
   \item \texttt{Section (Particles)}  This section describes all the
   particles in the system.  It is comprised of one or more
   \texttt{Species} sections.
     \subitem \texttt{Section (Species)}  Describes a group of
        identicle particles.  Examples include electrons, protons,
        or helium atoms.
        \subsubitem acdkajdf
\end{itemize}

\section{The ``Action'' section}
\section{The ``Moves'' section}
PIMC++ deals with moves and observables in a two steps. First, in this
section of the input file, the possible moves (observables) are
defined and given their appropriate parameters (i.e. what species they
will work on, how many levels the bisection has, etc).  Then, in the
algorithms section these moves are called.  This gives you flexibility
over when the moves happen during the PIMC run.  

\begin{itemize}
   \item \texttt{type}:  Type of move that is being
   defined.  For example, if you are defining a BisectionBlock move
   then your type will be BisectionBlock.

   \item \texttt{name}:  The name of your move. This may be anything
   but must be unique for each move in your Input File (the code should
   really check for this, btw).  This is the name you will use in the
   algorithm in specifying that this move is to be called.
\end{itemize}

\subsection{BisectionBlock Moves}
 
\begin{itemize}

   \item \texttt{Species}: string variable that contains the name of
   the species that the Move operates on.  This name should correspond
   to the value given to \texttt{Name} in the \texttt{Species}
   section.


   \item \texttt{PermuteType}: Indicates how (and whether) this move
   does permutations.  Note that this currently is a better indicator
   of whether the system is acting Bosonic then the statistics type of
   the species.  Choices include \texttt{Table} which performs up to 4
   particle permutations and \texttt{None} which indicates no
   permutations will happen.

   \item \texttt{Array<double,1> Gamma(4)}: Array of enhancement
     factors for 1,2,3, and 4 particle
     permutations when using a \texttt{PermuteType} of \texttt{Table}.
     These {\em must} be greater then 1.  Each factor will
     multiplicatively enhance the
     probability a permutation (of the appropriate size) will be chosen.
     
   \item \texttt{epsilon}: a cutoff that forbids sampling permutations with
     a probability (as determined by the kinetic action) smaller then epsilon 
     of being accepted.  Only to be used with \texttt{PermuteType} of
     \texttt{Table}. Epsilon significantly increases the 
     effeciency of the permutation algorithm moving it from
     approximately a $n^4$ to a $n^2$ algorithm. 

\end{itemize}
\section{The ``Observables'' section}
\section{The ``Algorithm'' section}

\chapter{Analysis Tools}
\section{MakeReport}
\section{pathvis++}


\chapter{Modifing pimc++}
\section{Useful things to know}
Each particle in PIMC++ is indexed by a unique integer. 
\section{Adding a new ``Move''}
There are two steps to adding a new move. First, the move needs to be
created and then the appropriate files need to be changed to allow the
move to be ``glued'' into the rest of the code.

There are two types of moves. There are normal moves and then
multistage moves. We will start by discussion normal moves.

All normal moves must inherit from the class ParticleMoveClass and 
create the following four functions: \\
a constructor,\\
\texttt{MakeMove()},\\
\texttt{Read(IOSectionClass \&in)},  \\
\texttt{WriteRatio()}.

The constructor of a move must look like the following:\\

\rule{0.6cm}{0cm}\shadowbox{\begin{minipage}{4.4in}
\begin{verbatim}
  NameOfMyMoveClass(PathDataClass &myPathData, 
  IOSectionClass outSection) :
  ParticleMoveClass(myPathData,outSection)
    {
      /* Add code you want here */
    }
\end{verbatim}
\end{minipage}}

It is important to remember to send a pathdata reference and an
  IOSectionClass to ParticleMoveClass as is done above. This is so the
  move has access to the pathdata and an ability to write out data
  like its acceptance ratio

The function \texttt{MakeMove()} will be called by the algorithm 
and is in charge of the entire move. This means that it is in charge
of performing the metropolis proceudure by itself (This includes calling
the appropriate actions and then using a random number to decide on 
acceptance or rejection)
At the end of the move, it is {\em mandatory} that \texttt{MakeMove()} 
either accepts or
rejects the move by calling either \\
\rule{0.6cm}{0cm}\shadowbox{\begin{minipage}{4.4in}
\begin{verbatim}
PathData.Path.AcceptMove(startSlice,endSlice,ActiveParticles)
\end{verbatim}
\end{minipage}}\\
if the move is accepted or by calling\\
\rule{0.6cm}{0cm}\shadowbox{\begin{minipage}{4.4in}
\begin{verbatim}
PathData.Path.RejectMove(startSlice,endSlice,ActiveParticles) 
\end{verbatim}
\end{minipage}}\\
 if the move is rejected.  
The parameters sent to these functions
include the range (inclusive) of slices that the move has altered as
well as an array of particle indices 
(of type  \texttt{Array<int,1>}) that the move has changed.  
By accepting the move, all knowledge of the previous state of the path
will be erased. By rejecting the move all changes the move made in the
slice ranges defined by \texttt{[startSlice:endSlice]} on the particles defined
by the array \texttt{ActiveParticles} will be overwritten by the previous state
of the path at these locations.  


We will not worry about \texttt{WriteRatio()} for the time being other then to
say that it is relevant for getting the acceptance ratio outputs
correctly.

The function \texttt{Read(IOSectionClass \&in)} is called immediately after the
move is created so that the move has the opportunity to read relevant
input information.  When it is called, the IOSectionClass object
\texttt{in} will be located inside the \texttt{Section (Move)} that 
has the name of your move which
will be inside \texttt{Section (Moves)}.
 The move is then responsible for reading the input parameters it needs
by calling \texttt{in.Readvar(``varString'',var)}. For example, it might read the 
number of levels it is to operate on by calling 
\texttt{in.ReadVar(``NumLevels'',numLevels)} Note,
that the Read function is responsible for closing any sections it
opens, but {\em NOT} for closing the section it is in (i.e. there needs to
be exactly the same number of \texttt{OpenSection} and 
\texttt{CloseSection} calls in
your \texttt{Read} function).

To glue the read function into your code, there are currently three
steps. First, perform the appropriate incanation on the configuration scripts.
Secondly,  your move needs
to be added to the .h file of \texttt{MovesClass.h}. This ensures that it will
get included when other files \#include the moves. Finally, inside
PIMCClass.cc, there is a ReadMoves() function which will need to have your
move added to it.  In the series of ``if'' statements, you need to add
\\
\rule{0.6cm}{0cm}\shadowbox{\begin{minipage}{4.4in}
\begin{verbatim}
 else if (MoveType==''MyMoveType''){
    moveName=''MyMoveName'';
    Moves(counter)=new MyMoveClass(PathData,OutFile);
    Moves(counter)->Read(in);
}
\end{verbatim}
\end{minipage}}\\
The moveType will have to be the type the user must type under
\texttt{Section (Move)} for your move.




\section{Adding a new ``Observable''}
There are two steps to adding a new observable. First, the observable
needs to be created and then appropriate files need to be changed to
allow the observable to be ``glued'' into the rest of the code.
\subsection{Creating an observable}
All observables are located in the Observables directory underneath
the src directory. All observables inherit from the function
ObservableClass (located in ObservableBase.h). Every observable has a
``name'' and a ``description'' and all
observables must implement the functions: \\
\texttt{void Accumulate()} \\
\texttt{void WriteBlock()} \\ 
The following functions may be overwritten by an observable, but need
not be: \\
\texttt{void Read(IOSectionClass\& IO)} \\
\texttt{void WriteInfo()} \\
A standard observable should also have two variables called \texttt{Freq} and
\texttt{DumpFreq} that are read in from the input file and respectively
establish how many times the observable must be called before it
accumulates its running average and how many times it must be called
before it outputs its running average to the output file.

To simplify the writing of observables, one should use 
the children of the \texttt{ObservableVar} class. (Such children include 
\texttt{ObservableDouble},\texttt{ObservableVecDouble1},
\texttt{ObsservableInt},etc.) One of these should be used for each
variable you write (recurringly) to your hdf file.  
To use them you must call their constructor with three parameters:
the name of the variable to be used in the output file, a reference to 
an IOSectionClass that will NOT be deleted upon exiting the constructor
(concretely this means that you need to call it with the capatilized and not
lowercase version of IOSection), and I reference to a communicator that 
will be used among the time slice parallel versions of the ...

First we examine how the ObservableVariables are created.
\subsubsection{Accumulate()}
The accumulate function gets called each time that an observable is
told to accumulate in the code's algorithm.  A correctly implemented
accumulate should call WriteBlock() every DumpFreq amount of times and
should perform the functions inside of itself every Freq amount of
times it is called.  The functions inside of itself should add onto
its running average the value of the observable it is in charge
of. For example if it was an energy observable, it might accumulate
the running sum of the kinetic and potential energies.

\chapter{Code Verification}
abcdef
\end{document}

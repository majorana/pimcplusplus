\documentclass{book}
%\usepackage{verbatim}
%\usepackage{moreverb}
%\usepackage{boxedminipage}
%\usepackage{shadow}
\usepackage{fancybox}
\usepackage{float}

\renewcommand{\shadowsize}{2pt}
\author{Kenneth P. Esler, Jr.}
\title{pimc++}
%\subtitle{Path Integral Monte Carlo Simulation Tool}

\begin{document}
\maketitle
\chapter{Introduction}
{\em pimc++} is a general, high-performance tool to perform
fully-correlated simulations of quantum systems at finite temperature.
In essense, it samples the many-body thermal density matrix to compute
thermal equilibrium averages of quantum observables.  Written in very
object-oriented C++, it is intended to be a nearly universal tool that
can be easily extended to perform novel simulations.  Its current
features include:
\begin{itemize}
  \item Arbitrary number of particles, species, and timeslices,
        limited only by memory requirements.
  \item Time-slices can be distributed across processors using MPI to
        communicate, making possible efficient simulations with
        thousands of time-slices.
  \item Multiple ``clones'' of the same simulation may be run with
        automatic generation of different random number seeds.  This
        can be used to improve statistics.
  \item Very high-accuracy pair-actions can be used.  These are
        generated with the coupled squarer++/fitter++ package.
  \item Bose, Fermi, and Boltzmann statistics are supported.
  \item Output is efficiently and accurately stored in HDF5 format.
  \item Extremely flexible input file format allows specification of
        the Monte Carlo algorithm in the input.
  \item Free and periodic boundary conditions are specified
        independently for each dimension allowing slab and column
        geometries. 
  \item Statistical analysis and HTML report generation with
        automatic creation of embedded plots.
  \item 3D OpenGL-based visualization tool can be used for debugging
        and pedagogy.  Supports exporting to the POVray ray-tracer for 
        photo-realistic rendering.  Also supports MPEG4 movie generation.
\end{itemize}

\chapter{Installing}
Suffice it to say that installing {\em pimc++} can be a quite a pain
in the caboose.

\chapter{Input Files}
\section{Introduction}
All of the file input and output in pimc++ is done through our 
C++ Input And Output ({\em CIAO}) library.  This library is designed
to provide a common programming interface to several hierachical data
formats.  In particular, we currently implement a custom ASCII format,
HDF5, and XML.  For input files, we use the ASCII format almost
exclusively.  For files which store heavy numeric data, such as the
pair action spline tables, we use HDF5.  XML is appealing for some
compatibility reasons, but we do not currently use it for anything.
The following sections will explain the use of our ASCII format.  

\section{Defining variables}
Upon looking at a sample input file, the reader will note a strong
resemblence to C++.  This was an intentional choice on the part of the
developers, since those who were familiar enough with C++ to extend
the code should feel quite at-home with this format.  There are very
few constructs to learn in the input files, yet we have found them to
be very versatile.  

Before diving into the details of the file format, let us begin with
an example.  In Figure~\ref{fig:InputEx}, we have a fictitious input
file in the {\em CIAO} ASCII format.
\begin{figure}
\shadowbox{\begin{minipage}{5in}
\begin{verbatim}
Section(System) {
  int NumParticles = 6;
  Array<double,1> Masses(6) = [ 0.5, 0.5, 0.5, 1.0, 1.0, 1.0 ];
}

Section(Potentials) {
  Section(Potential) {
    string Type = "Coulomb";
    double q1 = 1.0;
    double q2 = -1.0;
  }

  Section(Potential) {
    string Type = "Lennard-Jones";
    double sigma = 5.0;    // this is in units of bohr radii
    double epsilon = 3.2;  // and this is in Hartrees
  }
}
\end{verbatim}
\end{minipage}}
\caption{Example {\em CIAO} input file.}
\label{fig:InputEx}
\end{figure}

The most basic construct is a named variable to which a value is
assigned.  An example is \\
\rule{0.6cm}{0cm}\shadowbox{\parbox{4.4in}{\texttt{int NumParticles = 6;}}} \\
In this case, \texttt{NumParticles} is an {\em atomic} variable.
Currently, {\em CIAO} supports the atomic types {\texttt int, double,
  bool and string}.  It also supports array variables.  We have taken
the syntax for our array variables from the popular {\em blitz++}
template array package. \\
\rule{0.6cm}{0cm}\shadowbox{\parbox{4.4in}{\texttt{Array<double,1>
      Masses(6) = [0.5, 0.5, 0.5, 1.0, 1.0, 1.0]; }}} \\
Here, the \texttt{Array<double,1>} indicates a one-dimensional array
of doubles.  {\emCIAO} supports up to four-dimensional arrays.  The
\texttt{(6)} after the variable name, \texttt{Masses}, gives the size
of the array.  For a multidimensional array, the dimensions are
separated by commas, such as\\
\rule{0.6cm}{0cm}\shadowbox{\begin{minipage}{4.4in}
\begin{verbatim}
Array<double,2> Ident(3,3) = [ 1.0, 0.0, 0.0,
                               0.0, 1.0, 0.0,
                               0.0, 0.0, 1.0 ];
\end{verbatim}
\end{minipage}}\\
The blank lines are not required -- they are included only for
clarity.  



\section{Creating hierachy with sections}

\section{Format}
\section{Global parameters}
\section{The ``System'' section}
\section{The ``Action'' section}
\section{The ``Moves'' section}
\section{The ``Observables'' section}
\section{The ``Algorithm'' section}

\chapter{Analysis Tools}
\section{MakeReport}
\section{pathvis++}

\chapter{Modifing pimc++}
\section{Adding a new ``Move''}
There are two steps to adding a new move. First, the move needs to be
created and then the appropriate files need to be changed to allow the
move to be ``glued'' into the rest of the code.

There are two types of moves. There are normal moves and then
multistage moves. We will start by discussion normal moves.

All normal moves must inheret from the class ParticleMoveClass and 
create the following four functions: a
constructor, MakeMove(), Read(IOSectionClass &in),  and WriteRatio().

The constructor of a move must look like the following:\\
  NameOfMyMoveClass(PathDataClass &myPathData,IOSectionClass outSection) :
  ParticleMoveClass(myPathData,outSection)
    {
      /* Add code you want here */
    }
It is important to remember to send a pathdata reference and an
  IOSectionClass to ParticleMoveClass as is done above. This is so the
  move has access to the pathdata and an ability to write out data
  like its acceptance ratio

The function MakeMove() is in charge of the entire move.  At the end
of the move, it is mandatory that the function either accepts or
rejects the move by calling either
PathData.Path.AcceptMove(startSlice,endSlice,ActiveParticles) if the
move is accepted or by calling 
PathData.Path.RejectMove(startSlice,endSlice,ActiveParticles) if the
move is rejected.  The parameters that are sent to these function
include the range (inclusive) of slices that the move has altered as
well as a Array<int,1> of particles that the move has changed.  By
accepting the move, all knowledge of the previous state of the path
will be erased. By rejecting the move all changes the move made in the
slice ranges defined by [startSlice:endSlice] on the particles defined
by the array ActiveParticles will be overwritten by the previous state
of the path at these locations.  Therefore, the move needs to do all
the metropolis steps by itself. It is also responsible for ensuring
that it calls and uses the correct actions.

We will not worry about WriteRatio() for the time being other then to
say that it is relevant for getting the acceptance ratio outputs
correctly.

The function Read(IOSectionClass &in) is called immediately after the
move is created so that the move has the opportunity to read relevant
input information.  When it is called, the IOSectionClass object
``in'' will be located inside the section of the input class relevant
to this move.  The move is then responsible for doing the appropriate
in.Readvar(``varString'',var) to read the appropriate variables. Note,
that the Read function is responsible for closing any sections it
opens, but NOT for closing the section it is in (i.e. there needs to
be exactly the same number of OpenSection and CloseSection calls in
your Read function).

To glue the read function into your code, there are currently four
steps. First, you must add the move to the src/Moves/template.make and
src/template.make file in the appropriate places (i.e. anyplace that
MultiStage.* shows up, you need to add YourMove.*).  Your move needs
to be added to the .h file of MovesClass.h. This ensures that it will
get included when other files #include other moves. Finally, inside
PIMCClass.cc, there is a ReadMoves() file which will need to have your
move added to it.  In the series of ``if'' statements, you need to add
\\
    else if (MoveType==''MyMoveType''){
      moveName=''MyMoveName'';
      Moves(counter)=new MyMoveClass(PathData,OutFile);
      Moves(counter)->Read(in);
    }



\section{Adding a new ``Observable''}
There are two steps to adding a new observable. First, the observable
needs to be created and then appropriate files need to be changed to
allow the observable to be ``glued'' into the rest of the code.
\subsection{Creating an observable}
All observables are located in the Observables directory underneath
the src directory. All observables inherit from the function
ObservableClass (located in ObservableBase.h). Every observable has a
``name'' and a ``description'' and all
observables must implement the functions: \\
void Accumulate() \\
void WriteBlock() \\ 
The following functions may be overwritten by an observable, but need
not be: \\
void Read(IOSectionClass& IO) \\
void WriteInfo() \\
A standard observable should also have two variables called Freq and
DumpFreq that are read in from the input file and respectively
establish how many times the observable must be called before it
accumulates its running average and how many times it must be called
before it outputs its running average to the output file.
Each of these functions will be discussed later.  First we examine how
the ObservableVariables are created.
\subsubsection{Accumulate()}
The accumulate function gets called each time that an observable is
told to accumulate in the code's algorithm.  A correctly implemented
accumulate should call WriteBlock() every DumpFreq amount of times and
should perform the functions inside of itself every Freq amount of
times it is called.  The functions inside of itself should add onto
its running average the value of the observable it is in charge
of. For example if it was an energy observable, it might accumulate
the running sum of the kinetic and potential energies.



\end{document}
